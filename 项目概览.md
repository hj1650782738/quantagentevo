# AlphaAgent 项目概览

> 最后更新：2026-01-15  
> 版本：Evolution 分支

## 📖 项目简介

**AlphaAgent** 是一个基于大语言模型（LLM）驱动的自主Alpha因子挖掘框架，通过三个专门的智能体来挖掘可解释且抗衰减的Alpha因子。

**Evolution 分支新特性**：引入了进化算法机制（变异和交叉），通过「原始轮 → 变异轮 → 交叉轮」的循环实现更高效的因子探索。

---

## 🎯 快速入口：运行实验

```bash
# 基本用法
bash /home/tjxy/quantagent/AlphaAgent/运行实验.sh "你的初始方向"

# 示例
bash /home/tjxy/quantagent/AlphaAgent/运行实验.sh "基于价量关系的动量因子"
```

---

## 🔄 核心工作流程图（Planning + Evolution 模式）

### 总体流程架构

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              用户输入初始方向                                      │
│                         例如: "基于价量关系的动量因子"                               │
└─────────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          STEP 1: Planning 方向扩展                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │ 调用 LLM 将初始方向扩展为 N 个并行探索方向                                  │   │
│  │ 配置: planning.num_directions = 2                                       │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  输出:                                                                          │
│    Direction 0: "基于价量关系的动量因子 + 短期动量信号配合成交量确认"                  │
│    Direction 1: "基于价量关系的动量因子 + 波动率区间切换使用滚动方差"                  │
└─────────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          STEP 2: 进化循环开始                                     │
│                                                                                 │
│  ╔═════════════════════════════════════════════════════════════════════════╗   │
│  ║                         Round 0: 原始轮 (ORIGINAL)                       ║   │
│  ╠═════════════════════════════════════════════════════════════════════════╣   │
│  ║                                                                         ║   │
│  ║   Direction 0 ─────────┐         Direction 1 ─────────┐                ║   │
│  ║                        ▼                               ▼                ║   │
│  ║              ┌─────────────────┐             ┌─────────────────┐       ║   │
│  ║              │   小流程循环     │             │   小流程循环     │       ║   │
│  ║              │  (5步一循环)     │             │  (5步一循环)     │       ║   │
│  ║              │                 │             │                 │       ║   │
│  ║              │ 1.factor_propose│             │ 1.factor_propose│       ║   │
│  ║              │ 2.factor_construct            │ 2.factor_construct       ║   │
│  ║              │ 3.factor_calculate            │ 3.factor_calculate       ║   │
│  ║              │ 4.factor_backtest             │ 4.factor_backtest        ║   │
│  ║              │ 5.feedback      │             │ 5.feedback      │       ║   │
│  ║              └────────┬────────┘             └────────┬────────┘       ║   │
│  ║                       ▼                               ▼                ║   │
│  ║              ┌─────────────────┐             ┌─────────────────┐       ║   │
│  ║              │  Trajectory 0   │             │  Trajectory 1   │       ║   │
│  ║              │  (原始轨迹0)     │             │  (原始轨迹1)     │       ║   │
│  ║              │  ├─假设         │             │  ├─假设         │       ║   │
│  ║              │  ├─因子表达式    │             │  ├─因子表达式    │       ║   │
│  ║              │  ├─回测指标     │             │  ├─回测指标     │       ║   │
│  ║              │  └─反馈         │             │  └─反馈         │       ║   │
│  ║              └─────────────────┘             └─────────────────┘       ║   │
│  ║                       │                               │                ║   │
│  ║                       └───────────┬───────────────────┘                ║   │
│  ║                                   ▼                                    ║   │
│  ║                          写入因子库 + 轨迹池                             ║   │
│  ║                          (phase=original)                              ║   │
│  ╚═════════════════════════════════════════════════════════════════════════╝   │
│                                        │                                        │
│                                        ▼                                        │
│  ╔═════════════════════════════════════════════════════════════════════════╗   │
│  ║                         Round 1: 变异轮 (MUTATION)                       ║   │
│  ╠═════════════════════════════════════════════════════════════════════════╣   │
│  ║                                                                         ║   │
│  ║  ┌─────────────────────────────────────────────────────────────────┐   ║   │
│  ║  │ 从原始轮的轨迹中选择父代，生成正交的变异假设                          │   ║   │
│  ║  │                                                                  │   ║   │
│  ║  │  原始轨迹0 ─────────────────┐     原始轨迹1 ─────────────────┐    │   ║   │
│  ║  │         │                   │            │                   │    │   ║   │
│  ║  │         ▼                   │            ▼                   │    │   ║   │
│  ║  │  ┌─────────────┐           │     ┌─────────────┐            │    │   ║   │
│  ║  │  │MutationOp   │           │     │MutationOp   │            │    │   ║   │
│  ║  │  │生成正交假设  │           │     │生成正交假设  │            │    │   ║   │
│  ║  │  └──────┬──────┘           │     └──────┬──────┘            │    │   ║   │
│  ║  │         │                   │            │                   │    │   ║   │
│  ║  │         ▼                   │            ▼                   │    │   ║   │
│  ║  │  ┌─────────────┐           │     ┌─────────────┐            │    │   ║   │
│  ║  │  │ 小流程循环   │           │     │ 小流程循环   │            │    │   ║   │
│  ║  │  └──────┬──────┘           │     └──────┬──────┘            │    │   ║   │
│  ║  │         ▼                   │            ▼                   │    │   ║   │
│  ║  │   变异轨迹0                 │       变异轨迹1                 │    │   ║   │
│  ║  └─────────────────────────────────────────────────────────────────┘   ║   │
│  ║                                                                         ║   │
│  ║  变异原则:                                                              ║   │
│  ║  • 生成与父代正交（近乎无关）的新策略                                     ║   │
│  ║  • 避免重复探索相同的方向                                                ║   │
│  ║  • 使用父代的反馈来规避已知陷阱                                          ║   │
│  ║                                                                         ║   │
│  ║  写入因子库 + 轨迹池 (phase=mutation)                                   ║   │
│  ╚═════════════════════════════════════════════════════════════════════════╝   │
│                                        │                                        │
│                                        ▼                                        │
│  ╔═════════════════════════════════════════════════════════════════════════╗   │
│  ║                        Round 2: 交叉轮 (CROSSOVER)                       ║   │
│  ╠═════════════════════════════════════════════════════════════════════════╣   │
│  ║                                                                         ║   │
│  ║  ┌─────────────────────────────────────────────────────────────────┐   ║   │
│  ║  │ 从前两轮选择父代，组合生成融合假设                                   │   ║   │
│  ║  │                                                                  │   ║   │
│  ║  │  第一次交叉轮的候选池:                                            │   ║   │
│  ║  │    ┌──────────────────────────────────────────────────────┐     │   ║   │
│  ║  │    │ 原始轨迹0, 原始轨迹1, 变异轨迹0, 变异轨迹1 (共4个)      │     │   ║   │
│  ║  │    └──────────────────────────────────────────────────────┘     │   ║   │
│  ║  │                           │                                      │   ║   │
│  ║  │                           ▼                                      │   ║   │
│  ║  │            ┌──────────────────────────────┐                     │   ║   │
│  ║  │            │ CrossoverOperator            │                     │   ║   │
│  ║  │            │ 选择 crossover_n 组父代组合   │                     │   ║   │
│  ║  │            │ (每组 crossover_size 个父代)  │                     │   ║   │
│  ║  │            │ 配置: size=2, n=2            │                     │   ║   │
│  ║  │            └──────────────────────────────┘                     │   ║   │
│  ║  │                           │                                      │   ║   │
│  ║  │         ┌─────────────────┴─────────────────┐                   │   ║   │
│  ║  │         ▼                                   ▼                   │   ║   │
│  ║  │  ┌────────────────┐               ┌────────────────┐           │   ║   │
│  ║  │  │ 组合1:          │               │ 组合2:          │           │   ║   │
│  ║  │  │ 原始0 + 变异1   │               │ 变异0 + 原始1   │           │   ║   │
│  ║  │  └───────┬────────┘               └───────┬────────┘           │   ║   │
│  ║  │          ▼                                 ▼                   │   ║   │
│  ║  │  ┌────────────────┐               ┌────────────────┐           │   ║   │
│  ║  │  │生成融合假设     │               │生成融合假设     │           │   ║   │
│  ║  │  │+ 小流程循环    │               │+ 小流程循环    │           │   ║   │
│  ║  │  └───────┬────────┘               └───────┬────────┘           │   ║   │
│  ║  │          ▼                                 ▼                   │   ║   │
│  ║  │    交叉轨迹0                          交叉轨迹1                 │   ║   │
│  ║  └─────────────────────────────────────────────────────────────────┘   ║   │
│  ║                                                                         ║   │
│  ║  交叉原则:                                                              ║   │
│  ║  • 融合多个父代策略的优势                                                ║   │
│  ║  • 寻找策略间的协同效应                                                  ║   │
│  ║  • 避免继承共同的缺陷                                                    ║   │
│  ║                                                                         ║   │
│  ║  注意: 交叉轮后并行度从 N → crossover_n (例如: 2 → 2)                    ║   │
│  ║                                                                         ║   │
│  ║  写入因子库 + 轨迹池 (phase=crossover)                                  ║   │
│  ╚═════════════════════════════════════════════════════════════════════════╝   │
│                                        │                                        │
│                                        ▼                                        │
│  ╔═════════════════════════════════════════════════════════════════════════╗   │
│  ║                         Round 3: 变异轮 (MUTATION)                       ║   │
│  ╠═════════════════════════════════════════════════════════════════════════╣   │
│  ║                                                                         ║   │
│  ║  变异目标: 上一轮交叉轮的输出 (交叉轨迹0, 交叉轨迹1)                      ║   │
│  ║                                                                         ║   │
│  ║   交叉轨迹0 ────────┐        交叉轨迹1 ────────┐                        ║   │
│  ║                     ▼                          ▼                        ║   │
│  ║           ┌──────────────┐           ┌──────────────┐                  ║   │
│  ║           │ MutationOp   │           │ MutationOp   │                  ║   │
│  ║           │ 正交变异     │           │ 正交变异     │                  ║   │
│  ║           └──────┬───────┘           └──────┬───────┘                  ║   │
│  ║                  ▼                          ▼                          ║   │
│  ║           变异轨迹2                   变异轨迹3                         ║   │
│  ║                                                                         ║   │
│  ║  写入因子库 + 轨迹池 (phase=mutation)                                   ║   │
│  ╚═════════════════════════════════════════════════════════════════════════╝   │
│                                        │                                        │
│                                        ▼                                        │
│  ╔═════════════════════════════════════════════════════════════════════════╗   │
│  ║                        Round 4: 交叉轮 (CROSSOVER)                       ║   │
│  ╠═════════════════════════════════════════════════════════════════════════╣   │
│  ║                                                                         ║   │
│  ║  交叉候选池: 上一轮变异 + 上一轮交叉的结果                               ║   │
│  ║  即: (变异轨迹2, 变异轨迹3) + (交叉轨迹0, 交叉轨迹1)                      ║   │
│  ║                                                                         ║   │
│  ║  (重复变异-交叉循环直到达到 max_rounds)                                  ║   │
│  ╚═════════════════════════════════════════════════════════════════════════╝   │
│                                        │                                        │
│                                        ▼                                        │
│                               循环继续...                                       │
│                          变异轮 → 交叉轮 → 变异轮 → ...                          │
│                          直到 round_idx >= max_rounds                           │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              进化完成                                            │
│                                                                                 │
│   输出:                                                                         │
│   • 轨迹池 (trajectory_pool.json) - 所有轨迹及其回测指标                          │
│   • 因子库 (all_factors_library.json) - 所有生成的因子及其元数据                   │
│   • 进化状态 (evolution_state.json) - 可用于恢复/继续实验                         │
│   • 最佳轨迹排名 (按 RankIC 排序)                                                │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 🔍 小流程详解：单轮因子挖掘的 5 个步骤

```
┌─────────────────────────────────────────────────────────────────────┐
│                    小流程循环 (AlphaAgentLoop.run)                    │
│                         每轮 5 个步骤                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Step 1: factor_propose (假设生成)                                  │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ • 调用 HypothesisGen.gen(trace)                             │  │
│   │ • 输入: 初始方向 + 策略后缀(变异/交叉指导) + 历史反馈         │  │
│   │ • 输出: AlphaAgentHypothesis 对象                           │  │
│   │   - hypothesis: 完整假设描述                                 │  │
│   │   - concise_observation: 简洁观察                           │  │
│   │   - concise_justification: 合理性说明                       │  │
│   │   - concise_knowledge: 相关金融知识                         │  │
│   │   - concise_specification: 规范说明                         │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                              │                                      │
│                              ▼                                      │
│   Step 2: factor_construct (因子构建)                               │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ • 调用 Hypothesis2Experiment.convert(hypothesis, trace)     │  │
│   │ • 生成 3 个因子表达式 (配置: factors_per_hypothesis=3)       │  │
│   │ • 正则化检查:                                                │  │
│   │   - AST 相似度检查 (与已有因子库对比)                        │  │
│   │   - 复杂度控制 (自由参数比例 < 50%)                          │  │
│   │   - 唯一变量比例控制                                         │  │
│   │ • 输出: FactorExperiment 对象 (包含多个 FactorTask)          │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                              │                                      │
│                              ▼                                      │
│   Step 3: factor_calculate (因子计算)                               │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ • 调用 Developer.develop(factor_experiment)                 │  │
│   │ • 将因子表达式转换为 Python 代码                             │  │
│   │ • 使用函数库 (function_lib.py) 计算因子值                    │  │
│   │ • 代码执行与调试                                             │  │
│   │ • 输出: 计算完成的 FactorExperiment (含代码和因子值)         │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                              │                                      │
│                              ▼                                      │
│   Step 4: factor_backtest (回测)                                    │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ • 调用 Runner.develop(factor_experiment, use_local=True)    │  │
│   │ • 执行 Qlib 回测 (配置: timeout=600s)                        │  │
│   │ • 计算关键指标:                                              │  │
│   │   - IC: 信息系数                                             │  │
│   │   - ICIR: IC 信息比率                                        │  │
│   │   - RankIC: 排序 IC (主要评判指标)                           │  │
│   │   - RankICIR: 排序 ICIR                                      │  │
│   │   - 年化收益、最大回撤等                                     │  │
│   │ • 输出: 含回测结果的 FactorExperiment                        │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                              │                                      │
│                              ▼                                      │
│   Step 5: feedback (反馈生成)                                       │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ • 调用 Summarizer.generate_feedback(experiment, hypothesis) │  │
│   │ • LLM 分析回测结果，生成反馈:                                │  │
│   │   - observations: 结果观察                                   │  │
│   │   - hypothesis_evaluation: 假设评价                          │  │
│   │   - new_hypothesis: 新假设建议                               │  │
│   │   - decision: 是否替换最佳结果                               │  │
│   │ • 更新 Trace 历史记录                                        │  │
│   │ • 将因子写入因子库 (all_factors_library.json)                │  │
│   │   - 包含 evolution_phase 字段                                │  │
│   │   - 包含 trajectory_id 字段                                  │  │
│   │   - 包含 parent_trajectory_ids 字段                          │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 📁 代码调用链路详解

### 入口点：`运行实验.sh`

```bash
bash /home/tjxy/quantagent/AlphaAgent/运行实验.sh "用户输入"
```

```
运行实验.sh
    │
    ├── 1. 激活虚拟环境: source venv/bin/activate
    │
    ├── 2. 进入 AlphaAgent 目录
    │
    └── 3. 执行命令:
            alphaagent mine --direction "用户输入" --config_path run_config.yaml
                │
                ▼
```

### CLI 入口：`alphaagent/app/cli.py`

```python
# 命令注册
app.add_command(mine_command)  # 'mine' 子命令

@app.command("mine")
def mine_command(direction, step_n, config_path, evolution_mode):
    from alphaagent.app.qlib_rd_loop.factor_mining import main
    main(direction=direction, step_n=step_n, config_path=config_path, evolution_mode=evolution_mode)
```

### 主入口：`factor_mining.py::main()`

```
factor_mining.py::main()
    │
    ├── 1. 加载配置: load_run_config(config_file)
    │       → run_config.yaml
    │       → planning_cfg, exec_cfg, evolution_cfg
    │
    ├── 2. 判断是否启用进化模式
    │       if evolution_cfg.enabled and path is None:
    │
    ├── [进化模式] ─────────────────────────────────────────────────────┐
    │       │                                                          │
    │       └── run_evolution_loop()                                   │
    │               │                                                  │
    │               ├── 2.1 生成初始方向                                │
    │               │       generate_parallel_directions()              │
    │               │       → planning.py                              │
    │               │                                                  │
    │               ├── 2.2 创建进化控制器                              │
    │               │       EvolutionController(config)                │
    │               │       → controller.py                            │
    │               │                                                  │
    │               └── 2.3 进化主循环                                  │
    │                       while not controller.is_complete():        │
    │                           task = controller.get_next_task()      │
    │                           ├── ORIGINAL → _get_original_task()    │
    │                           ├── MUTATION → _get_mutation_task()    │
    │                           │      └── MutationOperator            │
    │                           └── CROSSOVER → _get_crossover_task()  │
    │                                  └── CrossoverOperator           │
    │                                                                  │
    │                           traj_data = _run_evolution_task()      │
    │                           └── AlphaAgentLoop().run(step_n=5)     │
    │                                   └── 小流程 5 步                │
    │                                                                  │
    │                           controller.report_task_complete()      │
    │                                                                  │
    └── [传统模式] ─────────────────────────────────────────────────────┐
            │                                                          │
            ├── 如果 planning.enabled:                                 │
            │       generate_parallel_directions()                     │
            │                                                          │
            └── 串行/并行执行各方向:                                    │
                    AlphaAgentLoop().run(step_n=step_n)                │
                                                                       │
```

---

## 🏗️ 核心类与数据结构

### 1. 进化相关类

```
alphaagent/components/evolution/
├── __init__.py          # 导出所有进化组件
├── trajectory.py        # 策略轨迹与轨迹池
│   ├── RoundPhase       # 枚举: ORIGINAL, MUTATION, CROSSOVER
│   ├── StrategyTrajectory  # 单条策略轨迹
│   │   ├── trajectory_id      # 唯一标识
│   │   ├── direction_id       # 方向ID
│   │   ├── round_idx          # 轮次索引
│   │   ├── phase              # 阶段类型
│   │   ├── hypothesis         # 假设文本
│   │   ├── factors            # 因子列表
│   │   ├── backtest_metrics   # 回测指标
│   │   ├── feedback           # 反馈文本
│   │   └── parent_ids         # 父代轨迹ID列表
│   └── TrajectoryPool   # 轨迹池管理
│       ├── add()             # 添加轨迹
│       ├── get_by_phase()    # 按阶段获取
│       ├── get_by_direction()# 按方向获取
│       └── get_statistics()  # 统计信息
│
├── mutation.py          # 变异操作器
│   └── MutationOperator
│       ├── generate_mutation()           # 生成变异假设
│       └── generate_mutation_prompt_suffix() # 生成指导后缀
│
├── crossover.py         # 交叉操作器
│   └── CrossoverOperator
│       ├── generate_crossover()          # 生成融合假设
│       ├── select_crossover_pairs()      # 选择父代组合
│       └── generate_crossover_prompt_suffix() # 生成指导后缀
│
└── controller.py        # 进化控制器
    ├── EvolutionConfig  # 进化配置
    │   ├── num_directions       # 方向数量
    │   ├── max_rounds           # 最大轮数
    │   ├── crossover_size       # 每组父代数
    │   └── crossover_n          # 交叉组数
    └── EvolutionController
        ├── get_next_task()          # 获取下一任务
        ├── report_task_complete()   # 报告任务完成
        ├── _prepare_mutation_targets() # 准备变异目标
        ├── _get_crossover_candidates() # 获取交叉候选
        └── is_complete()            # 检查是否完成
```

### 2. 工作流类

```
alphaagent/components/workflow/
└── alphaagent_loop.py
    └── AlphaAgentLoop
        ├── __init__()
        │   ├── potential_direction   # 初始方向
        │   ├── strategy_suffix       # 策略指导后缀
        │   ├── evolution_phase       # 进化阶段
        │   ├── trajectory_id         # 轨迹ID
        │   └── parent_trajectory_ids # 父代ID列表
        │
        ├── factor_propose()    # Step 1: 假设生成
        ├── factor_construct()  # Step 2: 因子构建
        ├── factor_calculate()  # Step 3: 因子计算
        ├── factor_backtest()   # Step 4: 回测
        ├── feedback()          # Step 5: 反馈 + 写入因子库
        │
        └── _get_trajectory_data() # 获取轨迹数据（供进化控制器使用）
```

---

## ⚙️ 配置文件说明

### 核心配置：`run_config.yaml`

```yaml
# 位置: alphaagent/app/qlib_rd_loop/run_config.yaml

planning:
  enabled: true              # 启用 Planning
  num_directions: 2          # 并行方向数量
  use_llm: true              # 使用 LLM 生成方向

execution:
  max_loops: 7               # 传统模式下的最大循环数
  steps_per_loop: 5          # 每循环步数（固定为5）
  use_local: true            # 使用本地环境回测
  parallel_execution: true   # 并行执行分支

evolution:
  enabled: true              # 启用进化模式 ⭐
  max_rounds: 7              # 最大进化轮数
  crossover_size: 2          # 每次交叉的父代数量
  crossover_n: 2             # 每轮交叉的组合数量
  prefer_diverse_crossover: true  # 偏好多样化交叉

backtest:
  timeout: 600               # 回测超时（秒）

llm:
  factor_mining_timeout: 7200  # 挖掘总超时（秒）
```

### Planning 与 Evolution 的关系

| 配置组合 | 行为 |
|---------|------|
| `planning.enabled=true` + `evolution.enabled=false` | 传统模式：Planning 生成 N 个方向，串行/并行执行 |
| `planning.enabled=true` + `evolution.enabled=true` | **进化模式**：Planning 生成初始方向，然后进入进化循环 |
| `planning.enabled=false` + `evolution.enabled=true` | 进化模式：使用单一方向（或空方向）开始进化 |

### 参数说明

| 参数 | 说明 |
|------|------|
| `max_loops` | 传统模式下的循环数，进化模式下不生效 |
| `max_rounds` | 进化模式下的总轮数（包括原始、变异、交叉轮） |
| `crossover_size` | 每次交叉操作选择多少个父代（默认2） |
| `crossover_n` | 每轮交叉生成多少个新轨迹（决定交叉后的并行度） |

---

## 📊 因子库字段说明

因子写入 `all_factors_library.json` 时包含以下字段：

```json
{
  "factor_id": "唯一标识",
  "factor_name": "因子名称",
  "expression": "因子表达式",
  "description": "因子描述",
  
  // 进化相关字段 ⭐
  "evolution_phase": "original/mutation/crossover",
  "trajectory_id": "所属轨迹ID",
  "parent_trajectory_ids": ["父代轨迹ID列表"],
  
  // 回测指标
  "IC": 0.023,
  "ICIR": 0.45,
  "RankIC": 0.031,
  "RankICIR": 0.52,
  
  // 元数据
  "experiment_id": "实验ID",
  "round_number": 1,
  "hypothesis": "假设文本",
  "planning_direction": "规划方向",
  "created_at": "创建时间"
}
```

---

## 🔄 进化轮次逻辑总结

### 轮次与阶段对应关系

| Round | Phase | 说明 | 变异目标/交叉候选 |
|-------|-------|------|------------------|
| 0 | ORIGINAL | 原始探索 | N/A |
| 1 | MUTATION | 第一次变异 | 变异目标: Round 0 的原始轨迹 |
| 2 | CROSSOVER | 第一次交叉 | 候选池: 原始(R0) + 变异(R1) |
| 3 | MUTATION | 第二次变异 | 变异目标: Round 2 的交叉结果 |
| 4 | CROSSOVER | 第二次交叉 | 候选池: 变异(R3) + 交叉(R2) |
| 5 | MUTATION | 第三次变异 | 变异目标: Round 4 的交叉结果 |
| ... | ... | ... | ... |

### 关键原则

1. **变异轮**：从上一轮的输出中选择父代进行正交变异
   - 第一次变异：变异原始轮的轨迹
   - 后续变异：变异上一次交叉轮的结果

2. **交叉轮**：从最近两轮的结果中选择候选进行融合
   - 第一次交叉：原始轮 + 最近变异轮
   - 后续交叉：最近变异轮 + 最近交叉轮

3. **并行度变化**：
   - 初始：`num_directions` 个并行分支
   - 交叉后：`crossover_n` 个并行分支

---

## 📂 项目目录结构

```
AlphaAgent/
├── alphaagent/
│   ├── app/
│   │   ├── cli.py                    # CLI 入口
│   │   └── qlib_rd_loop/
│   │       ├── factor_mining.py      # ⭐ 主入口，进化循环
│   │       ├── planning.py           # Planning 方向生成
│   │       ├── run_config.yaml       # ⭐ 核心配置文件
│   │       ├── planning_prompts.yaml # Planning 提示词
│   │       └── evolution_prompts.yaml# 进化提示词
│   │
│   ├── components/
│   │   ├── evolution/                # ⭐ 进化模块
│   │   │   ├── controller.py         # 进化控制器
│   │   │   ├── trajectory.py         # 轨迹管理
│   │   │   ├── mutation.py           # 变异操作
│   │   │   └── crossover.py          # 交叉操作
│   │   │
│   │   ├── workflow/
│   │   │   └── alphaagent_loop.py    # ⭐ 小流程循环
│   │   │
│   │   ├── coder/
│   │   │   └── factor_coder/
│   │   │       ├── expr_parser.py    # 表达式解析
│   │   │       ├── function_lib.py   # 因子函数库
│   │   │       └── factor_ast.py     # AST 相似度检测
│   │   │
│   │   └── proposal/                 # 假设生成
│   │
│   ├── scenarios/qlib/               # Qlib 场景
│   │   ├── proposal/                 # 假设与因子提案
│   │   ├── developer/                # 因子开发与回测
│   │   ├── experiment/               # 实验管理
│   │   └── regulator/                # 因子正则化
│   │
│   └── utils/
│       └── env.py                    # 执行环境（本地/Docker）
│
├── 运行实验.sh                        # ⭐ 快速启动脚本
├── 终止实验.sh                        # 终止实验脚本
├── all_factors_library.json          # 因子库输出
├── factor_library_manager.py         # 因子库管理器
└── 项目概览.md                        # 本文档
```

---

## 🛠️ 故障排查

### 常见问题

1. **回测卡在 90% 不动**
   - 原因：Qlib 回测在某些日期可能较慢
   - 解决：已添加超时机制（默认 600 秒），超时后自动终止

2. **pandas 索引对齐错误**
   - 错误信息：`ValueError: Can only compare identically-labeled Series objects`
   - 解决：已修复 `function_lib.py` 中的索引对齐逻辑

3. **因子生成失败**
   - 检查 LLM API 连接
   - 查看日志：`log/<branch_name>/common_logs.log`

### 日志位置

```
log/
├── original_00_00/      # 原始轮 direction_0
├── mutation_01_00/      # 变异轮 round_1 direction_0
├── crossover_02_00/     # 交叉轮 round_2 direction_0
├── trajectory_pool.json # 轨迹池
└── evolution_state.json # 进化状态（可用于恢复）
```

---

## 📚 相关资源

- **论文**: [AlphaAgent: LLM-Driven Alpha Mining](https://arxiv.org/abs/2502.16789)
- **Qlib 项目**: https://github.com/microsoft/qlib
- **RD-Agent**: https://github.com/microsoft/RD-Agent

---

*文档版本: Evolution 分支 | 更新日期: 2026-01-15*
